{
  "hash": "9bb491fec042111b93e0230cdbaa5feb",
  "result": {
    "markdown": "---\ntitle: \"19 Visualise And Analyse Time-Oriented Data\"\nsubtitle: Hands-On Exercise for Week 7\ndate: last-modified\nauthor: \"KB\"\neditor: visual\nexecute:\n  freeze: auto \n  warning: false\nformat:\n  html:\n    code-fold: true\n    code-summary: \"Show the code\"\n    code-line-numbers: true\n    toc-depth: 4\n---\n\n\n(First Published: Jul 5, 2023)\n\n## 19.1 Learning Outcome\n\nWe will learn how to create the following visualisations:\n\n-   plotting a calender heatmap,\n\n-   plotting a cycle plot,\n\n-   plotting a slopegraph, and\n\n-   plotting a horizon chart\n\n## 19.2 Getting Started\n\n### 19.2.1 Install and load the required R libraries\n\nInstall and load the the required R packages. The name and function of the new packages that will be used for this exercise are as follow\n\n-   **scales** : provides various functions for scaling and formatting data\n-   **viridis** : provides color palettes that are perceptually uniform and work well for representing data in visualisations\n-   **gridExtra** : provides functions for arranging multiple plots on a page or within a plot\n-   **readxl** :enables reading data from Microsoft Excel files (.xls and .xlsx) into R\n-   **knitr** :used for dynamic report generation in R\n-   **data.table** :offers fast data manipulation and aggregation operations, making it useful for working with large datasets\n-   **CGPfuntions** : contains a function that is designed to automate the process of producing a [Tufte style slopegraph](https://www.edwardtufte.com/bboard/q-and-a-fetch-msg?msg_id=0003nk) using `ggplot2`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(scales, viridis, lubridate, ggthemes, gridExtra, readxl, knitr, data.table, CGPfunctions, ggHoriPlot, tidyverse, CGPfunctions) \n```\n:::\n\n\n## 19.3 Plotting Calendar Heatmap\n\nIn this section, we will learn how to plot a calender heatmap programmetically by using **ggplot2** package.\n\n### 19.3.1 Import the data\n\n*eventlog.csv* file consists of 199,999 rows of time-series cyber attack records by a country. It is imported in R and assigned to the *attacks* data frame.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nattacks <- read_csv(\"data/eventlog.csv\", show_col_types = F)\n```\n:::\n\n\n### 19.3.2 Examine the data structure\n\n`kable()` can be used to review the structure of the imported data frame.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nkable(head(attacks))\n```\n\n::: {.cell-output-display}\n|timestamp           |source_country |tz              |\n|:-------------------|:--------------|:---------------|\n|2015-03-12 15:59:16 |CN             |Asia/Shanghai   |\n|2015-03-12 16:00:48 |FR             |Europe/Paris    |\n|2015-03-12 16:02:26 |CN             |Asia/Shanghai   |\n|2015-03-12 16:02:38 |US             |America/Chicago |\n|2015-03-12 16:03:22 |CN             |Asia/Shanghai   |\n|2015-03-12 16:03:45 |CN             |Asia/Shanghai   |\n:::\n:::\n\n\nThere are three columns, namely *timestamp*, *source_country* and *tz*.\n\n-   *timestamp* field stores date-time values in POSIXct format.\n\n-   *source_country* field stores the source of the attack. It is in *ISO 3166-1 alpha-2* country code.\n\n-   *tz* field stores time zone of the source IP address.\n\n### 19.3.3 Data Preparation\n\nStep 1: Deriving *weekday* and *hour of day* fields\n\nBefore we can plot the calender heatmap, two new fields namely *wkday* and *hour* need to be derived. In this step, we will write a function to perform the task.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmake_hr_wkday <- function(ts, sc, tz) {\n  real_times <- ymd_hms(ts, \n                        tz = tz[1], \n                        quiet = TRUE)\n  dt <- data.table(source_country = sc,\n                   wkday = weekdays(real_times),\n                   hour = hour(real_times))\n  return(dt)\n  }\n```\n:::\n\n\n::: callout-note\n## Things to note:\n\n-   [`ymd_hms()`](https://lubridate.tidyverse.org/reference/ymd_hms.html) and [`hour()`](https://lubridate.tidyverse.org/reference/hour.html) are from [**lubridate**](https://lubridate.tidyverse.org/) package, and\n\n-   [`weekdays()`](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/weekdays) is a **base** R function.\n:::\n\nStep 2: Deriving the attacks tibble data frame\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwkday_levels <- c('Saturday', 'Friday', \n                  'Thursday', 'Wednesday', \n                  'Tuesday', 'Monday', \n                  'Sunday')\n\nattacks <- attacks %>%\n  group_by(tz) %>%\n  do(make_hr_wkday(.$timestamp, \n                   .$source_country, \n                   .$tz)) %>% \n  ungroup() %>% \n  mutate(wkday = factor(\n    wkday, levels = wkday_levels),\n    hour  = factor(\n      hour, levels = 0:23))\n```\n:::\n\n\n::: callout-note\n## Things to note:\n\nBeside extracting the necessary data into *attacks* data frame, `mutate()` of **dplyr** package is used to convert *wkday* and *hour* fields into **factor** so they'll be ordered when plotting.\n:::\n\nThe table below shows the tidy tibble table after processing.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nkable(head(attacks))\n```\n\n::: {.cell-output-display}\n|tz           |source_country |wkday    |hour |\n|:------------|:--------------|:--------|:----|\n|Africa/Cairo |BG             |Saturday |20   |\n|Africa/Cairo |TW             |Sunday   |6    |\n|Africa/Cairo |TW             |Sunday   |8    |\n|Africa/Cairo |CN             |Sunday   |11   |\n|Africa/Cairo |US             |Sunday   |15   |\n|Africa/Cairo |CA             |Monday   |11   |\n:::\n:::\n\n\n### 19.3.4 Building a Calendar Heatmap\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngrouped <- attacks %>% \n  count(wkday, hour) %>% \n  ungroup() %>%\n  na.omit()\n\nggplot(grouped, \n       aes(hour, \n           wkday, \n           fill = n)) + \ngeom_tile(color = \"white\", \n          size = 0.1) + \ntheme_tufte(base_family = \"Helvetica\") + \ncoord_equal() +\nscale_fill_gradient(name = \"# of attacks\",\n                    low = \"sky blue\", \n                    high = \"dark blue\") +\nlabs(x = NULL, \n     y = NULL, \n     title = \"Attacks by weekday and time of day\") +\ntheme(axis.ticks = element_blank(),\n      plot.title = element_text(hjust = 0.5),\n      legend.title = element_text(size = 8),\n      legend.text = element_text(size = 6) )\n```\n\n::: {.cell-output-display}\n![](Hands-On_Ex7a_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\n::: callout-note\n## Things to note:\n\n-   a tibble data table called *grouped* is derived by aggregating the attack by *wkday* and *hour* fields.\n\n-   a new field called *n* is derived by using `group_by()` and `count()` functions.\n\n-   `na.omit()` is used to exclude missing value.\n\n-   `geom_tile()` is used to plot tiles (grids) at each x and y position. `color` and `size` arguments are used to specify the border color and line size of the tiles.\n\n-   [`theme_tufte()`](https://jrnold.github.io/ggthemes/reference/theme_tufte.html) of [**ggthemes**](https://jrnold.github.io/ggthemes/reference/) package is used to remove unnecessary chart junk. To learn which visual components of default ggplot2 have been excluded, you are encouraged to comment out this line to examine the default plot.\n\n-   `coord_equal()` is used to ensure the plot will have an aspect ratio of 1:1.\n\n-   `scale_fill_gradient()` function is used to creates a two colour gradient (low-high).\n:::\n\n### 19.3.5 Building Multiple Calendar Heatmaps\n\nStep 1: Deriving attack by country object\n\nIn order to identify the top 4 countries with the highest number of attacks, we can do the followings:\n\n-   count the number of attacks by country,\n\n-   calculate the percent of attackes by country, and\n\n-   save the results in a tibble data frame.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nattacks_by_country <- count(\n  attacks, source_country) %>%\n  mutate(percent = percent(n/sum(n))) %>%\n  arrange(desc(n))\n```\n:::\n\n\nStep 2: Preparing the tidy data frame\n\nIn this step, we extract the attack records of the top 4 countries from *attacks* data frame and save the data in a new tibble data frame (i.e.Â *top4_attacks*).\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntop4 <- attacks_by_country$source_country[1:4]\ntop4_attacks <- attacks %>%\n  filter(source_country %in% top4) %>%\n  count(source_country, wkday, hour) %>%\n  ungroup() %>%\n  mutate(source_country = factor(\n    source_country, levels = top4)) %>%\n  na.omit()\n```\n:::\n\n\nStep 3: Plotting the Multiple Calender Heatmap by using ggplot2 package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(top4_attacks, \n       aes(hour, \n           wkday, \n           fill = n)) + \n  geom_tile(color = \"white\", \n          size = 0.1) + \n  theme_tufte(base_family = \"Helvetica\") + \n  coord_equal() +\n  scale_fill_gradient(name = \"# of attacks\",\n                    low = \"sky blue\", \n                    high = \"dark blue\") +\n  facet_wrap(~source_country, ncol = 2) +\n  labs(x = NULL, y = NULL, \n     title = \"Attacks on top 4 countries by weekday and time of day\") +\n  theme(axis.ticks = element_blank(),\n        axis.text.x = element_text(size = 7),\n        plot.title = element_text(hjust = 0.5),\n        legend.title = element_text(size = 8),\n        legend.text = element_text(size = 6) )\n```\n\n::: {.cell-output-display}\n![](Hands-On_Ex7a_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\n## 19.4 Plotting Cycle Plot\n\n### 19.4.1 Import the data\n\nThe codes below import *arrivals_by_air.xlsx* by using `read_excel()` of readxl package and save it as a tibble data frame called *air.*\n\n\n::: {.cell}\n\n```{.r .cell-code}\nair <- read_excel(\"data/arrivals_by_air.xlsx\")\n```\n:::\n\n\n### 19.4.2 Data Preparation\n\nNext, two new fields called *month* and *year* are derived from *Month-Year* field.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nair$month <- factor(month(air$`Month-Year`), \n                    levels=1:12, \n                    labels=month.abb, \n                    ordered=TRUE) \nair$year <- year(ymd(air$`Month-Year`))\n```\n:::\n\n\nThen, we extract the data for the target country (i.e. Vietnam)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nVietnam <- air %>% \n  select(`Vietnam`, \n         month, \n         year) %>%\n  filter(year >= 2010)\n```\n:::\n\n\nThereafter, we compute year average arrivals by month.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhline.data <- Vietnam %>% \n  group_by(month) %>%\n  summarise(avg_value = mean(`Vietnam`))\n```\n:::\n\n\n### 19.4.3 Generating the Cycle Plot\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Plot the graph\nggplot() + \n  geom_line(data=Vietnam,\n            aes(x=factor(year), # Set year to factor to ensure that x-axis label is formatted as 4-digit year\n                y=`Vietnam`, \n                group=month), \n            colour=\"black\") +\n  geom_hline(aes(yintercept=avg_value), \n             data=hline.data, \n             linetype=6, \n             colour=\"red\", \n             size=0.5) + \n  facet_grid(~month) +\n  labs(axis.text.x = element_text(angle = 90, hjust = 1),\n       title = \"Visitor arrivals from Vietnam by air, Jan 2010-Dec 2019\") +\n  xlab(\"Year\") +\n  ylab(\"No. of Visitors\")+\n  # Added to rotate the x-axis labels 90 degrees clockwise so that they don't overlap\n  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +\n  # Added this line to display year label every 3 years on the x-axis to reduce clutter and overlapping of the year\n  scale_x_discrete(breaks = function(x) x[seq(1, length(x), 3)])\n```\n\n::: {.cell-output-display}\n![](Hands-On_Ex7a_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n:::\n\n\n### 19.5 Plotting a Slopegraph\n\n::: callout-note\n## Note:\n\nBefore getting start, make sure that **CGPfunctions** has been installed and loaded onto R environment. Then, refer to [Using newggslopegraph](https://cran.r-project.org/web/packages/CGPfunctions/vignettes/Using-newggslopegraph.html) to learn more about the function. Lastly, read more about `newggslopegraph()` and its arguments by referring to this [link](https://www.rdocumentation.org/packages/CGPfunctions/versions/0.6.3/topics/newggslopegraph).\n:::\n\n### 19.5.1 Import the data\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrice <- read_csv(\"data/rice.csv\", show_col_types = F)\n```\n:::\n\n\n### 19.5.2 Generate the Slopegraph\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrice %>% \n  mutate(Year = factor(Year)) %>%\n  filter(Year %in% c(1961, 1980)) %>%\n  newggslopegraph(Year, Yield, Country,\n                Title = \"Rice Yield of Top 11 Asian Counties\",\n                SubTitle = \"1961-1980\",\n                Caption = \"Prepared by: Dr. Kam Tin Seong\")\n```\n\n::: {.cell-output-display}\n![](Hands-On_Ex7a_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n:::\n\n\n::: callout-note\n## Things to note:\n\nFor effective data visualisation design, `factor()` is used convert the value type of *Year* field from numeric to factor.\n:::\n\n::: {style=\"text-align: center\"}\n$**That's$ $all$ $folks!**$\n:::\n",
    "supporting": [
      "Hands-On_Ex7a_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}